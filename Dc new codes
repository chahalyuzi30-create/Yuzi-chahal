This README contains several MATLAB codes for Digital Communications and related topics. I will provide each experiment's code in a separate block, formatted for easy copying, as requested.

### ðŸ“š Experiment 1: Gram-Schmidt Orthonormalization

This code implements the Gram-Schmidt process to convert a set of linearly independent vectors into an orthonormal basis, and then visualizes both sets of vectors in 3D.

```matlab
clc;
clear;

V = [1 0 0; 1 1 1; 0 0 1]';
num_vectors = size(V, 2);

U = zeros(size(V));
E = zeros(size(V));

U(:,1) = V(:,1);
E(:,1) = U(:,1) / norm(U(:,1));

for i = 2:num_vectors
    U(:,i) = V(:,i);
    for j = 1:i-1
        U(:,i) = U(:,i) - (dot(E(:,j), V(:,i))) * E(:,j);
    end
    E(:,i) = U(:,i) / norm(U(:,i));
end

disp('Orthonormal basis vectors (columns):');
disp(E);

figure;
hold on;
grid on;
axis equal;

quiver3(0,0,0, V(1,1), V(2,1), V(3,1), 'r','LineWidth',2);
quiver3(0,0,0, V(1,2), V(2,2), V(3,2), 'g','LineWidth',2);
quiver3(0,0,0, V(1,3), V(2,3), V(3,3), 'b','LineWidth',2);

quiver3(0,0,0, E(1,1), E(2,1), E(3,1), 'r--','LineWidth',2);
quiver3(0,0,0, E(1,2), E(2,2), E(3,2), 'g--','LineWidth',2);
quiver3(0,0,0, E(1,3), E(2,3), E(3,3), 'b--','LineWidth',2);

xlabel('X');
ylabel('Y');
zlabel('Z');
legend('v1','v2','v3','e1','e2','e3');
title('Original and Orthonormal Basis Vectors');
hold off;
```

-----

### ðŸ“¡ Experiment 2: QPSK Modulation and Constellation

This code simulates the Quadrature Phase-Shift Keying (QPSK) modulation process and plots the resulting signals and the constellation diagram.

```matlab
clc;
clear all;
close all;

bit_seq = [1 1 0 0 0 0 1 1];
N = length(bit_seq);
fc = 1;
t_sample = 0.001;
t_symbol = 1;
t = 0:t_sample:t_symbol;

b = [];
for i = 1:N
    bx = bit_seq(i) * ones(1, length(t));
    b = [b, bx];
end

bit_seq_polar = bit_seq;
bit_seq_polar(bit_seq_polar == 0) = -1;

b_o = bit_seq_polar(1:2:end);
b_e = bit_seq_polar(2:2:end);

qpsk1 = [];
bec = [];
bes = [];
bit_e_plot = [];
bit_o_plot = [];

for i = 1:length(b_e)
    
    be_c = b_e(i) * cos(2*pi*fc*t);
    bo_s = b_o(i) * sin(2*pi*fc*t);
    q = be_c + bo_s;

    qpsk1 = [qpsk1, q];
    bec = [bec, be_c];
    bes = [bes, bo_s];
    
    bit_e_plot = [bit_e_plot, b_e(i)*ones(1, length(t))];
    bit_o_plot = [bit_o_plot, b_o(i)*ones(1, length(t))];
end

figure('Name', 'QPSK Modulation', 'NumberTitle', 'off');

subplot(5,1,1); 
plot(b, 'LineWidth', 1.5); 
grid on; 
axis([0 N*length(t) -0.5 1.5]); 
title('Binary Input Sequence'); 
ylabel('Amplitude');

subplot(5,1,2); 
plot(bes, 'b', 'LineWidth', 1.2); 
hold on; 
plot(bit_o_plot, 'r--'); 
grid on; 
axis([0 N*length(t) -1.5 1.5]); 
title('Odd Bits (Sine Component)'); 
ylabel('Amplitude');

subplot(5,1,3); 
plot(bec, 'g', 'LineWidth', 1.2); 
hold on; 
plot(bit_e_plot, 'r--'); 
grid on; 
axis([0 N*length(t) -1.5 1.5]); 
title('Even Bits (Cosine Component)'); 
ylabel('Amplitude');

subplot(5,1,4); 
plot(qpsk1, 'k', 'LineWidth', 1.2); 
grid on; 
axis([0 N*length(t) -2 2]); 
title('QPSK Modulated Signal'); 
ylabel('Amplitude');

subplot(5,1,5); 
constellation = [1+1j, -1+1j, -1-1j, 1-1j]; 
plot(real(constellation), imag(constellation), 'bo', 'MarkerSize', 8, 'LineWidth', 2); 
grid on; 
axis([-2 2 -2 2]); 
title('QPSK Constellation Diagram'); 
xlabel('In-phase (I)'); 
ylabel('Quadrature (Q)');
axis square;
```

-----

### ðŸ“Š Experiment 3: BER vs. SNR for Digital Modulation

This code simulates the Bit Error Rate (BER) performance against Signal-to-Noise Ratio (SNR) for a simple baseband rectangular pulse modulation scheme using a matched filter.

```matlab
clc;
clear all;
close all;

N = 1e4;
SNR_dB = 0:5:20;
pulse_width = 1;
data = randi([0 1], N, 1);
t_sample = 0.01;
t = 0:t_sample:pulse_width;
rect_pulse = ones(size(t));

BER = zeros(length(SNR_dB), 1);

for snr_idx = 1:length(SNR_dB)
    
    tx_signal = [];
    for i = 1:N
        if data(i) == 1
            tx_signal = [tx_signal; rect_pulse'];
        else
            tx_signal = [tx_signal; zeros(size(rect_pulse'))];
        end
    end
    
    SNR = 10^(SNR_dB(snr_idx) / 10);
    
    % Assuming signal energy Es = 1 for a '1' pulse. Noise power for a matched
    % filter output: No/2 = 1/(2*SNR) * Es/Eb * Eb/No
    % With Es = Eb for this binary scheme, and noise variance sigma^2 = No/2.
    % To get AWGN such that SNR is defined as Es/No:
    % Noise variance is No/2. For Es=1, No = 1/SNR. So, variance = 1/(2*SNR).
    noise_power = 1 / (2 * SNR);
    noise = sqrt(noise_power) * randn(length(tx_signal), 1);
    
    rx_signal = tx_signal + noise;
    
    matched_filter = rect_pulse;
    filtered_signal = conv(rx_signal, matched_filter, 'same');
    
    sample_interval = length(t);
    sampled_signal = filtered_signal(sample_interval/2:sample_interval:end - sample_interval/2);
    
    % Adjust if data size doesn't perfectly match sampled size
    if length(sampled_signal) > N
        sampled_signal = sampled_signal(1:N);
    end
    
    estimated_bits = sampled_signal > (pulse_width/2); % Decision boundary is 0.5*Es*T
    
    num_errors = sum(estimated_bits ~= data);
    BER(snr_idx) = num_errors / N;
    
end

figure;
semilogy(SNR_dB, BER, 'b-o');
grid on;
xlabel('SNR (dB)');
ylabel('Bit Error Rate (BER)');
title('BER vs. SNR for Rectangular Pulse Modulated Binary Data');
```

-----

### ðŸŽ¨ Experiment 4: 16-QAM Constellation

This code generates and plots the constellation diagram for 16-Quadrature Amplitude Modulation (16-QAM) symbols, both ideal and with Added White Gaussian Noise (AWGN).

```matlab
clc;
clear all;
close all;

M = 16;
N = 10000;
bits = randi([0 1], 1, N);
symbols = zeros(1, N/4);

for i = 1:N/4
    
    % Gray coding mapping for 16-QAM constellation points
    % This is one specific mapping.
    I1 = 2*bits(4*i-3)-1;
    Q1 = 2*bits(4*i-2)-1;
    I2 = 2*bits(4*i-1)-1;
    Q2 = 2*bits(4*i)-1;
    
    symbols(i) = I1 + 1j*Q1 + 2*(I2) + 2j*(Q2);
end

figure;
scatter(real(symbols), imag(symbols), 'bo', 'filled');
grid on;
xlabel('In-phase');
ylabel('Quadrature');
title('16-QAM Constellation (Ideal)');
axis equal;
axis([-4 4 -4 4]);

snr_db = 20;
rx_signal = awgn(symbols, snr_db, 'measured');

figure;
plot(real(rx_signal), imag(rx_signal), 'ro', 'Markersize', 6);
xlabel('In-phase');
ylabel('Quadrature');
title(['16-QAM Constellation with AWGN (SNR = ' num2str(snr_db) ' dB)']);
grid on;
axis equal;
axis([-4 4 -4 4]);
```

-----

### ðŸŒ³ Experiment 5: Huffman Coding

This code demonstrates Huffman coding, including generating the dictionary, encoding a symbol sequence, and decoding a bit stream.

```matlab
clc;
clear;

p = input('Enter the probabilities (e.g., [0.5 0.25 0.125 0.125]): ');
n = length(p);
symbols = 1:n;

[dict, avglen] = huffmandict(symbols, p);

disp('The Huffman code dictionary:');
for i = 1:n
    fprintf('Symbol %d: %s\n',symbols(i), num2str(dict{i, 2}));
end
fprintf('Average Code Length: %f\n', avglen);

sym = input(sprintf('Enter the symbols between 1 to %d in []: ', n));
encoded = huffmanenco(sym, dict);
disp('The encoded output:');
disp(encoded);

bits = input('Enter the bit stream in []: ');
decoded = huffmandeco(bits, dict);
disp('The decoded symbols are:');
disp(decoded);
```

-----

### ðŸ›¡ï¸ Experiment 6: Hamming Code (7,4)

This code demonstrates the encoding and single-bit error detection/correction process using a Hamming (7,4) code.

```matlab
clc;
clear;

data = [1 0 1 0]; 

% Calculate parity bits for Hamming (7,4)
% p1 = d1 + d2 + d4 (positions 3, 5, 7)
p1 = mod(data(1) + data(2) + data(4), 2);
% p2 = d1 + d3 + d4 (positions 3, 6, 7)
p2 = mod(data(1) + data(3) + data(4), 2);
% p3 = d2 + d3 + d4 (positions 5, 6, 7)
p3 = mod(data(2) + data(3) + data(4), 2);

% Encoded data: [p1 p2 d1 p3 d2 d3 d4]
encoded_data = [p1 p2 data(1) p3 data(2) data(3) data(4)]; 

disp('Encoded Data:');
disp(encoded_data);

% Simulate receiving data with an error (e.g., bit at position 4 flipped: p3)
recieved_data = [1 0 1 1 0 1 0]; 
disp('Received data:');
disp(recieved_data);

% Calculate syndrome bits (s3 s2 s1)
recv = recieved_data;

% s1 = p1 + d1 + d2 + d4 (positions 1, 3, 5, 7)
s1 = mod(recv(1) + recv(3) + recv(5) + recv(7), 2);
% s2 = p2 + d1 + d3 + d4 (positions 2, 3, 6, 7)
s2 = mod(recv(2) + recv(3) + recv(6) + recv(7), 2);
% s3 = p3 + d2 + d3 + d4 (positions 4, 5, 6, 7)
s3 = mod(recv(4) + recv(5) + recv(6) + recv(7), 2);

% Syndrome vector: [s3 s2 s1] -> decimal error location
error_location = bin2dec([num2str(s3) num2str(s2) num2str(s1)]);

if error_location ~= 0
    fprintf('Bit error detected at position %d. Correcting...\n', error_location);
    recv(error_location) = mod(recv(error_location) + 1, 2);
    fprintf('Corrected data:\n');
    disp(recv);
else
    disp('No error detected.');
end

% Extract original data bits: [d1 d2 d3 d4] (positions 3, 5, 6, 7)
decoded_data = recv([3 5 6 7]); 
disp('Decoded Data (4 bits):');
disp(decoded_data);
```

-----

### ðŸ”— Experiment 7: Convolutional Coding and Viterbi Decoding

This code demonstrates encoding a message using a convolutional code and then decoding a noisy version of the encoded message using the Viterbi algorithm.

```matlab
clc;
clear;
close all;

msg = [1 0 1 1 0 1 0 0];

% Constraint length K=3. Generator polynomials G1=7 (111), G2=5 (101) in octal.
constraint_length = 3; 
generator_polynomials = [7 5];

% Create the trellis structure
trellis = poly2trellis(constraint_length, generator_polynomials);

% Encode the message
encoded_msg = convenc(msg, trellis);

% Introduce a single bit error for simulation
encoded_msg_noisy = encoded_msg; 
% Flip the 4th bit (just an example)
encoded_msg_noisy(4) = ~encoded_msg_noisy(4);

% Viterbi decode the noisy message
traceback_length = 5; % Typical length for good performance
decoded_msg = vitdec(encoded_msg_noisy, trellis, traceback_length, 'trunc', 'hard');

disp('Original Message:');
disp(msg);
disp('Encoded Message:');
disp(encoded_msg);
disp('Noisy Encoded Message (with bit flip):');
disp(encoded_msg_noisy);
disp('Decoded Message:');
disp(decoded_msg);
```

-----

I have provided all the codes in a copy-paste ready format. Would you like me to elaborate on the theory behind any of these experiments, such as the Viterbi algorithm or QAM?
